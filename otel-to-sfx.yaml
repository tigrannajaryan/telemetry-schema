# Section "all" applies to attributes names everywhere: resources, spans, logs, metric labels.
# The only translation possible in section "all" is renaming of attributes in
# versions. For human readability versions are listed in reverse chronological
# order, however note that the translations are applied in the order defined by
# semver ordering.
all:
  1.1.0:
    # Mapping of attribute names (label names for metrics). The key is the old name
    # used prior to this version, the value is the new name starting from this version.

    # dimensions
    container.image.name: container_image
    k8s.container.name: container_spec_name
    k8s.cluster.name: kubernetes_cluster
    k8s.daemonset.name: kubernetes_name
    k8s.daemonset.uid: kubernetes_uid
    k8s.deployment.name: kubernetes_name
    k8s.deployment.uid: kubernetes_uid
    k8s.hpa.name: kubernetes_name
    k8s.hpa.uid: kubernetes_uid
    k8s.namespace.name: kubernetes_namespace
    k8s.node.name: kubernetes_node
    k8s.node.uid: kubernetes_node_uid
    k8s.pod.name: kubernetes_pod_name
    k8s.pod.uid: kubernetes_pod_uid
    k8s.replicaset.name: kubernetes_name
    k8s.replicaset.uid: kubernetes_uid
    k8s.replicationcontroller.name: kubernetes_name
    k8s.replicationcontroller.uid: kubernetes_uid
    k8s.resourcequota.name: quota_name
    k8s.resourcequota.uid: kubernetes_uid
    k8s.statefulset.name: kubernetes_name
    k8s.statefulset.uid: kubernetes_uid
    host.name: host

    # properties
    cronjob_uid: cronJob_uid
    cronjob: cronJob
    daemonset_uid: daemonSet_uid
    daemonset: daemonSet
    k8s.workload.kind: kubernetes_workload
    k8s.workload.name: kubernetes_workload_name
    replicaset_uid: replicaSet_uid
    replicaset: replicaSet
    statefulset_uid: statefulSet_uid
    statefulset: statefulSet

  1.0.0: # No changes in this version. May be omitted.

  0.0.0: # Initial version, cannot specify any translations. May be omitted.

# Like "all" the "resources" section may contain only attribute renaming translations.
# The only translation possible in this section is renaming of attributes in
# versions.
resources:
  1.1.0:
    # Mapping of attribute names. The key is the old name
    # used prior to this version, the value is the new name starting from this version.
    telemetry.auto.version: telemetry.auto_instr.version

  1.0.0: # No changes for this version.

traces:
  1.1.0:
    peer.service: peer.service.name

metrics:
  1.1.0:
    # "all_metrics" section defines translations for all metrics, regardless of metric name.
    # The only translation possible in this section is renaming of metric labels.
    all_metrics:
      # Mapping of label names. The key is the old name used prior to this version,
      # the value is the new name starting from this version.
      http.status_code: http.response_status_code

    # "by_name" section defines translation for specific metrics only, specified by the
    #  name of the metric.
    by_name:
      rename_labels:
        # Name of the metric to apply this rule to.
        system.cpu.utilization:
          # Mapping of label names. The key is the old name used prior to this version,
          # the value is the new name starting from this version.
          # "status" label is renamed to "state" for metric "system.cpu.utilization".
          status: state

        system.memory.usage:
          status: state

        system.memory.utilization:
          status: state

        system.paging.usage:
          status: state

      rename_metric:
        # Rename metrics. Keys are old metric names, values are new metric names.

        # kubeletstats receiver metrics
        container.cpu.time: container_cpu_utilization
        container.filesystem.available: container_fs_available_bytes
        container.filesystem.capacity: container_fs_capacity_bytes
        container.filesystem.usage: container_fs_usage_bytes
        container.memory.available: container_memory_available_bytes
        container.memory.major_page_faults: container_memory_major_page_faults
        container.memory.page_faults: container_memory_page_faults
        container.memory.rss: container_memory_rss_bytes
        container.memory.usage: container_memory_usage_bytes
        container.memory.working_set: container_memory_working_set_bytes

        # k8s cluster receiver metrics
        k8s.container.cpu_limit: kubernetes.container_cpu_limit
        k8s.container.cpu_request: kubernetes.container_cpu_request
        k8s.container.ephemeral-storage_limit: kubernetes.container_ephemeral_storage_limit
        k8s.container.ephemeral-storage_request: kubernetes.container_ephemeral_storage_request
        k8s.container.memory_limit: kubernetes.container_memory_limit
        k8s.container.memory_request: kubernetes.container_memory_request
        k8s.container.ready: kubernetes.container_ready
        k8s.container.restarts: kubernetes.container_restart_count
        k8s.cronjob.active_jobs: kubernetes.cronjob.active
        k8s.daemonset.current_scheduled_nodes: kubernetes.daemon_set.current_scheduled
        k8s.daemonset.desired_scheduled_nodes: kubernetes.daemon_set.desired_scheduled
        k8s.daemonset.misscheduled_nodes: kubernetes.daemon_set.misscheduled
        k8s.daemonset.ready_nodes: kubernetes.daemon_set.ready
        k8s.deployment.available: kubernetes.deployment.available
        k8s.deployment.desired: kubernetes.deployment.desired
        k8s.job.active_pods: kubernetes.job.active
        k8s.job.desired_successful_pods: kubernetes.job.completions
        k8s.job.failed_pods: kubernetes.job.failed
        k8s.job.max_parallel_pods: kubernetes.job.parallelism
        k8s.job.successful_pods: kubernetes.job.succeeded
        k8s.hpa.current_replicas: kubernetes.hpa.status.current_replicas
        k8s.hpa.desired_replicas: kubernetes.hpa.status.desired_replicas
        k8s.hpa.max_replicas: kubernetes.hpa.spec.max_replicas
        k8s.hpa.min_replicas: kubernetes.hpa.spec.min_replicas
        k8s.namespace.phase: kubernetes.namespace_phase
        k8s.node.condition_memory_pressure: kubernetes.node_memory_pressure
        k8s.node.condition_network_unavailable: kubernetes.node_network_unavailable
        k8s.node.condition_out_of_disk: kubernetes.node_out_of_disk
        k8s.node.condition_p_i_d_pressure: kubernetes.node_p_i_d_pressure
        k8s.node.condition_ready: kubernetes.node_ready
        k8s.pod.phase: kubernetes.pod_phase
        k8s.replicaset.available: kubernetes.replica_set.available
        k8s.replicaset.desired: kubernetes.replica_set.desired
        k8s.replication_controller.available: kubernetes.replication_controller.available
        k8s.replication_controller.desired: kubernetes.replication_controller.desired
        k8s.resource_quota.hard_limit: kubernetes.resource_quota_hard
        k8s.resource_quota.used: kubernetes.resource_quota_used
        k8s.statefulset.current_pods: kubernetes.stateful_set.current
        k8s.statefulset.desired_pods: kubernetes.stateful_set.desired
        k8s.statefulset.ready_pods: kubernetes.stateful_set.ready
        k8s.statefulset.updated_pods: kubernetes.stateful_set.updated

        # load metrics
        system.cpu.load_average.15m: load.longterm
        system.cpu.load_average.5m: load.midterm
        system.cpu.load_average.1m: load.shortterm

        # dockerstats reciever
        container.blockio.io_merged_recursive.async: blkio.io_merged_recursive.async
        container.blockio.io_merged_recursive.discard: blkio.io_merged_recursive.discard
        container.blockio.io_merged_recursive.read: blkio.io_merged_recursive.read
        container.blockio.io_merged_recursive.sync: blkio.io_merged_recursive.sync
        container.blockio.io_merged_recursive.total: blkio.io_merged_recursive.total
        container.blockio.io_merged_recursive.write: blkio.io_merged_recursive.write
        container.blockio.io_queued_recursive.async: blkio.io_queue_recursive.async
        container.blockio.io_queued_recursive.discard: blkio.io_queue_recursive.discard
        container.blockio.io_queued_recursive.read: blkio.io_queue_recursive.read
        container.blockio.io_queued_recursive.sync: blkio.io_queue_recursive.sync
        container.blockio.io_queued_recursive.total: blkio.io_queue_recursive.total
        container.blockio.io_queued_recursive.write: blkio.io_queue_recursive.write
        container.blockio.io_service_bytes_recursive.async: blkio.io_service_bytes_recursive.async
        container.blockio.io_service_bytes_recursive.discard: blkio.io_service_bytes_recursive.discard
        container.blockio.io_service_bytes_recursive.read: blkio.io_service_bytes_recursive.read
        container.blockio.io_service_bytes_recursive.sync: blkio.io_service_bytes_recursive.sync
        container.blockio.io_service_bytes_recursive.total: blkio.io_service_bytes_recursive.total
        container.blockio.io_service_bytes_recursive.write: blkio.io_service_bytes_recursive.write
        container.blockio.io_service_time_recursive.async: blkio.io_service_time_recursive.async
        container.blockio.io_service_time_recursive.discard: blkio.io_service_time_recursive.discard
        container.blockio.io_service_time_recursive.read: blkio.io_service_time_recursive.read
        container.blockio.io_service_time_recursive.sync: blkio.io_service_time_recursive.sync
        container.blockio.io_service_time_recursive.total: blkio.io_service_time_recursive.total
        container.blockio.io_service_time_recursive.write: blkio.io_service_time_recursive.write
        container.blockio.io_serviced_recursive.async: blkio.io_serviced_recursive.async
        container.blockio.io_serviced_recursive.discard: blkio.io_serviced_recursive.discard
        container.blockio.io_serviced_recursive.read: blkio.io_serviced_recursive.read
        container.blockio.io_serviced_recursive.sync: blkio.io_serviced_recursive.sync
        container.blockio.io_serviced_recursive.total: blkio.io_serviced_recursive.total
        container.blockio.io_serviced_recursive.write: blkio.io_serviced_recursive.write
        container.blockio.io_time_recursive.async: blkio.io_time_recursive.async
        container.blockio.io_time_recursive.discard: blkio.io_time_recursive.discard
        container.blockio.io_time_recursive.read: blkio.io_time_recursive.read
        container.blockio.io_time_recursive.sync: blkio.io_time_recursive.sync
        container.blockio.io_time_recursive.total: blkio.io_time_recursive.total
        container.blockio.io_time_recursive.write: blkio.io_time_recursive.write
        container.blockio.io_wait_time_recursive.async: blkio.io_wait_time_recursive.async
        container.blockio.io_wait_time_recursive.discard: blkio.io_wait_time_recursive.discard
        container.blockio.io_wait_time_recursive.read: blkio.io_wait_time_recursive.read
        container.blockio.io_wait_time_recursive.sync: blkio.io_wait_time_recursive.sync
        container.blockio.io_wait_time_recursive.total: blkio.io_wait_time_recursive.total
        container.blockio.io_wait_time_recursive.write: blkio.io_wait_time_recursive.write
        container.blockio.sectors_recursive.async: blockio.sectors_recursive.async
        container.blockio.sectors_recursive.discard: blockio.sectors_recursive.discard
        container.blockio.sectors_recursive.read: blockio.sectors_recursive.read
        container.blockio.sectors_recursive.sync: blockio.sectors_recursive.sync
        container.blockio.sectors_recursive.total: blockio.sectors_recursive.total
        container.blockio.sectors_recursive.write: blockio.sectors_recursive.write
        container.cpu.percent: cpu.percent
        container.cpu.throttling_data.periods: cpu.throttling_data.periods
        container.cpu.throttling_data.throttled_periods: cpu.throttling_data.throttled_periods
        container.cpu.throttling_data.throttled_time: cpu.throttling_data.throttled_time
        container.cpu.usage.kernelmode: cpu.usage.kernelmode
        container.cpu.usage.percpu: cpu.percpu.usage
        container.cpu.usage.system: cpu.usage.system
        container.cpu.usage.total: cpu.usage.total
        container.cpu.usage.usermode: cpu.usage.usermode
        container.memory.active_anon: memory.stats.active_anon
        container.memory.active_file: memory.stats.active_file
        container.memory.cache: memory.stats.cache
        container.memory.dirty: memory.stats.dirty
        container.memory.hierarchical_memory_limit: memory.stats.hierarchical_memory_limit
        container.memory.hierarchical_memsw_limit: memory.stats.hierarchical_memsw_limit
        container.memory.inactive_anon: memory.stats.inactive_anon
        container.memory.inactive_file: memory.stats.inactive_file
        container.memory.mapped_file: memory.stats.mapped_file
        container.memory.percent: memory.percent
        container.memory.pgfault: memory.stats.pgfault
        container.memory.pgmajfault: memory.stats.pgmajfault
        container.memory.pgpgin: memory.stats.pgpgin
        container.memory.pgpgout: memory.stats.pgpgout
        container.memory.rss: memory.stats.rss
        container.memory.rss_huge: memory.stats.rss_huge
        container.memory.shmem: memory.stats.shmem
        container.memory.swap: memory.stats.swap
        container.memory.total_active_anon: memory.stats.total_active_anon
        container.memory.total_active_file: memory.stats.total_active_file
        container.memory.total_cache: memory.stats.total_cache
        container.memory.total_dirty: memory.stats.total_dirty
        container.memory.total_inactive_anon: memory.stats.total_inactive_anon
        container.memory.total_inactive_file: memory.stats.total_inactive_file
        container.memory.total_mapped_file: memory.stats.total_mapped_file
        container.memory.total_pgfault: memory.stats.total_pgfault
        container.memory.total_pgmajfault: memory.stats.total_pgmajfault
        container.memory.total_pgpgin: memory.stats.total_pgpgin
        container.memory.total_pgpgout: memory.stats.total_pgpgout
        container.memory.total_rss: memory.stats.total_rss
        container.memory.total_rss_huge: memory.stats.total_rss_huge
        container.memory.total_shmem: memory.stats.total_shmem
        container.memory.total_swap: memory.stats.total_swap
        container.memory.total_unevictable: memory.stats.total_unevictable
        container.memory.total_writeback: memory.stats.total_writeback
        container.memory.unevictable: memory.stats.unevictable
        container.memory.usage.limit: memory.usage.limit
        container.memory.usage.max: memory.usage.max
        container.memory.usage.total: memory.usage.total
        container.memory.writeback: memory.stats.writeback
        container.network.io.usage.rx_bytes: network.usage.rx_bytes
        container.network.io.usage.rx_dropped: network.usage.rx_dropped
        container.network.io.usage.rx_errors: network.usage.rx_errors
        container.network.io.usage.rx_packets: network.usage.rx_packets
        container.network.io.usage.tx_bytes: network.usage.tx_bytes
        container.network.io.usage.tx_dropped: network.usage.tx_dropped
        container.network.io.usage.tx_errors: network.usage.tx_errors
        container.network.io.usage.tx_packets: network.usage.tx_packets

      add_labels:
        # Add labels to a metric. Keys are metric names.
        # Note: this may need a different way to config to allow adding the same
        # label to many metrics.
        container.cpu.usage.total:
          # Labels to add as key/value paris.
          plugin: docker
        container.memory.usage.max:
          plugin: docker

      duplicate_labels:
        # Duplicate labels of a metric. Keys are metric names.
        # Note: this may need a different way to config to allow duplicating the same
        # label for many metrics.
        container.cpu.usage.total:
          # Maps of labels to copy. Keys are existing label names, values are new label
          # names. The value of the new label is set equal to the value of existing label.
          container.name: plugin_instance
        container.memory.usage.max:
          container.name: plugin_instance


      split:
        # Rules to split a metric into several metrics using a label for split.
        #
        # Name of old metric to split.
        system.memory.usage:
          # Name of label in the old metric to use for splitting. The label will be
          # eliminated, the new metric will not have it.
          # Note: this can be enhanced in the future to allow an array of labels
          # so that splitting can happen across more then one dimension.
          by_label: state
          # Names of new metrics to create, one for each possible value of label.
          labels_to_metrics:
            # If "state" label equals "used" create a new metric called "system.memory.used".
            used: system.memory.used
            free: system.memory.free
            cached: system.memory.cached

      merge:
        # List of rules to merge several metrics into a new metrics and add a label.
        #
        # Name of new metric to create.
        system.disk.io:
          # Name of label to add to the new metric.
          by_label: direction
          # Mapping of old metrics to new label values, one for each possible value of the
          #  new label.
          labels_for_metrics:
            # For old metric "system.disk.io.read" set "direction" label equal to "read".
            read: system.disk.io.read
            write: system.disk.io.write

      to_delta:
        # List of metric names to convert cumulative values to delta values.
        - system.cpu.time

      aggregate:
        # Aggregate the metric and eliminate the specified dimensions.
        system.cpu.total:
          aggregation_method: sum
          eliminate_labels:
            - state
            - cpu

logs: